#!/bin/bash
# vim: dict+=/usr/share/beakerlib/dictionary.vim cpt=.,w,b,u,t,i,k
#
#   Copyright (c) 2016 Red Hat, Inc.
#
#   This program is free software: you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation, either version 2 of
#   the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be
#   useful, but WITHOUT ANY WARRANTY; without even the implied
#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#   PURPOSE.  See the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see http://www.gnu.org/licenses/.
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   library-prefix = distribution_static__
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

rlImport "distribution/dump"

#
# Static file checking
#
# This library provides single function to help perform static file
# checking of installed RPM package.  By default,  several built-in
# checks are run.  If that is enough, all you need is call the
# function and it will take care of everything else.
#
# However, aside from this simple scenario, main strength of this
# function is that it already sorts files into lists in such a way
# that adding custom checks becomes easy.
#
# Another strength of this library is its simple but dynamic blacklisting
# so that your tests can be flexible but remain easy to understand and
# maintain.
#
#
# =head1 BUILT-IN CHECKS
#
# Built-in checks are few, to start with:
#
#  *  `syntax.python` -- syntax check for all possible Python scripts,
#
#  *  `syntax.bash` -- syntax check for all possible Bash scripts.
#
#  *  `conv.pam_d` -- check that files in /etc/pam.d/ are valid.
#
#  *  `conv.python.shebang` -- check for all possible Python scripts
#     that they use `#!/usr/bin/python`, not `#!/usr/bin/env`
#
#
# =head1 CUSTOM CHECKS
#
# Before understanding custom checks, we first need to look at
# way how file lists are organized.  Each check runs inside a directory
# organized like this:
#
#     .
#     ├── BLACKLIST
#     ├── all
#     │   ├── directories
#     │   ├── files
#     │   └── symlinks
#     ├── relics
#     ├── dist
#     │   └── pam.d
#     ├── ext
#     │   ├── NO.EXT
#     │   ├── bash
#     │   └── conf
#     ├── files.links
#     │   ├── _etc_foo_foo.conf -> /etc/foo/foo.conf
#     │   ├── _usr_share_lib64_foo_bar.so -> /usr/share/lib64/foo/bar.so
#     │   ├── _usr_share_lib64_foo_baz.so -> /usr/share/lib64/foo/baz.so
#     │   └── ...
#     ├── heur
#     │   ├── bash
#     │   └── python
#     ├── mime
#     │   ├── application
#     │   │   └── xml
#     │   └── text
#     │       ├── plain
#     │       └── x-shellscript
#     ├── rpmdata
#     │   ├── dump
#     │   ├── info
#     │   ├── list
#     │   ├── provides
#     │   ├── requires
#     │   └── scripts
#     └── tmp
#
# where "leaves" are individual path lists:
#
#  *  `all/..` - just based on basic UNIX type,
#  *  `BLACKLIST` - is generated by `distribution_static__mkblacklist()`,
#  *  `ext/..` - lists per file extension,
#  *  `mime/..`  - lists per MIME type as detected by file(1) utility,
#  *  `heur/..` - lists based on heuristics wired in this module,
#  *  `dist/..` - lists based on conventions given by distribution.
#
# `files.links` is not a list but a "flat" directory with symlinks to
# all files in the package.  This is useful if you want to use a tool
# with recursive mode such as grep, eg. `grep BAD_STRING -R files.links`
# may have vastly better performance than calling grep for each file
# in the package.
#
# `tmp` is also not a list, it's a directory designated for custom checks
# to allow keeping ad-hoc data (see Guildelines section of this manual).
# `relics` is similar except that this directory will be kept and
# submitted using rlFileSubmit along with all lists.
#
# `rpmdata` is another 'special' case; files here are direct exports from
# RPM database; where each file represents output of rpm query, where
# the query option corresponds to file name under rpmdata.  For example,
# output of `rpm --info` is saved under `rpmdata/info`.  As an addition,
# rpmdata/dump.real contains report similar to rpmdata/dump, but reflecting
# real state of filesystem rather than RPM database.  See RPMDATA MIRROR
# REPORT section for more details.
#
# Now, custom checks are added by implementing a check function and
# specifying it (and one of above lists, if needed) when calling
# `distribution_static__checks()`.
#
# There are two types of custom checks:
#
#
# =head2 Simple, typed check
#
# This is a simple function that runs on a particular path list as
# described above.  For each path, the check function is called with
# single argument of the path.
#
# The list can be relative path within the above structure, but also
# *another function*.  This helps make very specific checks by
# combining lists generated by this library and custom, package-specific
# filtering.
#
# The format can be one of:
#
#     SOME/LIST:SIMPLEFN
#     LISTFN:SIMPLEFN
#
# where LIST can be filename path relative to the directory described
# above.  Alternatively, you can write own function to produce the
# list (LISTFN); in that case you will use the second form.  SIMPLEFN
# is function  provided by you; it should accept path name of file being
# checked as single argument, and contain at least one beakerlib assert.
#
# For example, check 'all/files:foo' would call function `foo()` on each
# file (each line in `all/files` file).  Check 'heur/python:bar' would call
# `bar()` on each path from `heur/python` list.  Last, a check 'heya:baz'
# would run `baz()` with every line generated by calling `heya()`.
#
#
# =head2 Free form check
#
# Free-form check is just a user-defined function called in the
# path list directory described above.
#
# Two great advantages of *simple check* is that you don't have to care
# about the iteration code and it's easy to combine with any cached
# or custom-created lists.  Free-form check trades these feats for
# flexibility while still retaining access to cached lists.
#
# =head2 Guildelines
#
# When writing custom checks, try to follow these guidelines:
#
#  *  Do not change directory (if you absolutely have to, use pushd/popd).
#
#  *  Do not write anywhere except tmp/ sub-directory, created for you for
#     this purpose.
#
#  *  Prefix each assert with relevant filename (for simple checks, this
#     is passed as $1, for free-form, use absolute paths as read from
#     cached lists).
#
#
# =head1 BLACKLISTING
#
# If a function named `distribution_static__mkblacklist()` is defined,
# it must print a blacklist in form of lines as:
#
#     TEST_NAME:PATH
#
# Where TEST_NAME is name of the built-in test or a custom check function
# (SIMPLEFN), from which the PATH should be excluded.
#
#
# =head1 RPMDATA MIRROR REPORT
#
# File rpmdata/dump.real is created by this module and contains data in
# similar format as rpm --dump (ie. rpmdata/dump file), but reflecting
# real stat  This file can be useful when debugging rpm verification
# failures.
#
# The report will never be exactly the same, though, for several reasons.
# First, some fields cannot be reproduced by this module (eg. isconfig) or
# not reliably so (eg. rdev, size for directories...).  Second, files that
# were deleted from filesystem will be simply skipped.
#
# Also note that rpm allows explicitly excluding some fields from the rpm
# verification using %noverify field.  That is, these fields could be
# different in rpmdata/dump.real, and rpm check could still pass.
#
#
# =head1 EXAMPLE
#
# Skipping some boilerplate, this is body of a simple example of
# this function in action:
#
#
#     usepy3() {
#         rlRun "head -1 $1 | grep '#/usr/bin/python3'" \
#             1 "$(distribution_static__cmt) Python 3 is used"
#                #\
#         ## the comment is not mandatory, but we have added one
#         ## and by use of distribution_static__cmt() we ensure
#         ## the comment contains file path and check name already
#         ## formatted to copy/paste into blacklist
#     }
#
#     modules() {
#         grep -w /usr/lib/foo/modules heur/python
#                                     #\
#         ## we'll re-use existing list heur/python and just
#         ## filter it according to our specific criterion
#     }
#
#     distribution_static__mkblacklist() {
#         echo usepy3:/usr/share/doc/foo/bad_examples/obsolete.py
#                     #\
#         ## iow, this particular file will be skipped by
#         ## usepy3() test.  Few hints here:
#         ##  *  Instead of 'usepy3', we could also have used
#         ##     a custom built-in check name
#         ##  *  In case path  changes per distribution, we can
#         ##     pull it from rpm database
#     }
#
#     rlJournalStart
#
#         rlPhaseStartSetup 'init'
#             rlImport "distribution/static"
#         rlPhaseEnd
#
#         distribution_static__checks -c modules:usepy3 foo
#
#     rlJournalPrintText
#     rlJournalEnd
#
# Explanation:  The test is written for package 'foo'.  That is,
# `rpm -ql foo` will be used as basis for all file lists.  Built-in checks
# are called by default; we're topping this up with out custom "simple
# check".
#
# We could have used one of provided lists, eg. `heur/python:usepy3`
# ("things that look like Python") but we decided to focus only on
# particular subset of that.
#


#
# Blacklisting mode: 'filter', 'ignore' or 'verify' (default: 'filter')
#
# 'filter' is the usual mode when blacklist is working.  'ignore' will
# stop filtering, just as if blacklist was empty.
#
# 'verify' mode will try to detect obsolete blacklist items: it will
# run checks for all item, but will raise warning for items that would
# be filtered but did not really fail.
#
# It's recommended to run your tests with 'verify' once in a while, after
# a rebase or major change.
#
distribution_static__blacklist=${distribution_static__blacklist:-filter}

#
# Options for builtins
#
# Comma-separated list of K=V pairs where each KEY must
# start with builtin name, colon and option name.
#
#     BLTNNAME:OPTNAME=foo,BLTNNAME:OPTNAME=bar
#
# These values are available to the builtin via __distribution_static__opt()
# function.
#
distribution_static__bltnopts=${distribution_static__bltnopts:-}

distribution_static__cmt() {
    #
    # Get comment for rlRun inside custom check
    #
    # Assert comments are not mandatory but using this function you
    # this function will help you create comment:
    #
    #     CURRENT_CHECK:CURRENT_PATH
    #
    # which can be directly used in blacklist.
    #
    echo "$__distribution_static__test_name:$__distribution_static__item"
}

distribution_static__checks() {
    #
    # For a package, run built-in checks plus custom checks
    #
    # Usage:
    #
    #      distribution_static__checks [-R] [-B] [-b BUILTIN].. [-c CUSTOM_CHECK].. PKG"
    #
    # For package PKG, make lists and run
    #
    #  *   basic RPM integrity check, unless suppressed by -R,
    #
    #  *   all built-in checks, unless suppresed by `-B` or specified by `-b`,
    #
    #  *   all custom checks, if specified by -c.
    #
    # Finally, it will collect all intermediate relics (file lists, RPM data
    # and files dropped by custom checks, if any) as `PKG-NVR-relics.tar.gz`
    # ans upload it using rlFileSubmit for later reference.
    #
    # All necessary phases are created.
    #
    # Each CUSTOM_CHECK has to have one of this form:
    #
    #     SOME/LIST:SIMPLEFN
    #     LISTFN:SIMPLEFN
    #     FREEFN
    #
    # where SOME/LIST is a relative path to one of lists as described in
    # CUSTOM CHECKS section, LISTFN is name of a user-defined listing
    # function), SIMPLEFN is your simple check function name, and FREEFN
    # is name of your free-form check function.  Read CUSTOM CHECKS
    # section of this manual for details.
    #
    local Package           # package name to check
    local PackageNvr        # package NVR
    local lsthome           # list cache root
    local pktmp             # temporary directory for packaging relics
    local custs=()          # custom checks specified by `-c`
    local bltns=()          # builtin checks specified by `-b`
    local do_rpmv=true      # do `rpm -V` check?
    local do_bltns=true     # run builtins?
    local rpmv_tmp          # cache for `rpm -V` output

    while true; do case $1 in
        -R|--no-rpmv)    do_rpmv=false;  shift ;;
        -B|--no-builtin) do_bltns=false; shift ;;
        -c|--custom)     custs+=("$2");  shift 2 || { __distribution_static__usage; return 2; } ;;
        -b|--builtin)    bltns+=("$2");  shift 2 || { __distribution_static__usage; return 2; } ;;
        *) break ;;
    esac done
    Package=$1
    test -n "$2" && { __distribution_static__usage; return 2; }
    test -n "$Package" || { __distribution_static__usage; return 2; }

    PackageNvr=$(
        rpm --qf '%{NAME}-%{VERSION}-%{RELEASE}\n' -q "$Package" \
          | grep -vx 'package .* is not installed' \
          | sort \
          | uniq
    )

    test -n "$PackageNvr" || {
        __distribution_static__error \
            "package not installed: '$Package'"
        return 3
    }

    grep -qxF -e filter -e ignore -e verify <<<"$distribution_static__blacklist" || {
        __distribution_static__error \
            "invalid blacklisting mode: '$distribution_static__blacklist'"
        return 3
    }

    if $do_rpmv;
    then
        rlPhaseStartSetup "$PackageNvr: verify RPM integrity"
            rpmv_tmp=$(mktemp -t distribution_static.rpmv.XXXXXXXX)
            rlRun "rpm -V $Package >$rpmv_tmp" \
                0 "do rpm --verify on $Package"
            distribution_dump__file -E --skip-empty "$rpmv_tmp"
        rlPhaseEnd
    fi

    lsthome=$(mktemp -d -t "distribution_static__lsthome.XXXXXXXX")
    pushd "$lsthome" >/dev/null || {
        __distribution_static__error "could not move to temp"
        return 3
    }

        rlPhaseStartSetup "$PackageNvr: store rpm data"
            rlRun __distribution_static__make_rpmdata \
                0 "Store RPM data"
            rlRun __distribution_static__make_rpmreal \
                0 "Make rpm --dump \"mirror report\""
        rlPhaseEnd

        rlPhaseStartSetup "$PackageNvr: make lists"
            rlRun __distribution_static__make_lists \
                0 "Make lists of our files and dirs"
            rlRun __distribution_static__squash_lists \
                0 "Remove duplicates (possible in case of multilib)"
            rlRun __distribution_static__make_lists_mime \
                0 "Make MIME-type-based lists"
            rlRun __distribution_static__make_lists_ext \
                0 "make extension-based lists"
            rlRun __distribution_static__make_lists_dist \
                0 "make distribution-based lists"
            rlRun __distribution_static__make_lists_heur \
                0 "make heuristic-based lists"
            rlRun __distribution_static__make_links \
                0 "Make symlinks to our files in one big dir"
            touch BLACKLIST
            type -t "distribution_static__mkblacklist" >/dev/null && {
                rlRun "distribution_static__mkblacklist > BLACKLIST" \
                    0-255 "Make blacklist"
                distribution_dump__file BLACKLIST
            }
            rlLogInfo "distribution_static__blacklist='$distribution_static__blacklist'"
            case $distribution_static__blacklist in
                ignore) rlLogWarning "blacklist is ignored" ;;
                verify) rlLogWarning "blacklist is being verified" ;;
            esac

            rlRun "mkdir relics" \
                0 "create relics/ for writing"
            rlRun "mkdir tmp" \
                0 "create tmp/ for writing"

            {
                echo ITEMS LIST
                wc -l all/files
                wc -l all/directories
                wc -l all/symlinks
            } | column -t | distribution_dump__pipe LIST_STATS
        rlPhaseEnd

        $do_bltns && __distribution_static__run_builtins "${bltns[@]}"
        __distribution_static__run_customs "${custs[@]}"

    popd || {
        __distribution_static__error "could not move out of temp"
        return 3
    }

    pktmp=$(mktemp -d -t distribution_static__pktmp.XXXXXXXX)
    pushd "$pktmp" || {
        __distribution_static__error "could not move to: $pktmp"
        return 3
    }
        rlPhaseStartCleanup "$PackageNvr: collect relics"
            mkdir "$PackageNvr-relics"
            mv "$lsthome"/* "$PackageNvr-relics"
            rlRun "rm -rf $PackageNvr-relics/tmp" \
                0 "remove tmp/"
            rlRun "tar -czf '$PackageNvr-relics.tar.gz' '$PackageNvr-relics'" \
                0 "create tarball of file lists and relics"
            rlFileSubmit "$PackageNvr-relics.tar.gz"
        rlPhaseEnd
    popd || {
        __distribution_static__error "could not move out of tmp"
        return 3
    }
    rm -rf "$lsthome" "$pktmp"
}

_distribution_static__mkblacklist() {
    #
    # Print blacklist for tests
    #
    # Each line has to have format:
    #
    #     TEST_NAME:PATH
    #
    # Where TEST_NAME is name of the test from which the PATH should be
    # excluded.   In case of custom checks, FN shall be used as TEST_NAME.
    #
    true "this is template for distribution_static__mkblacklist"
}


#          #                    if you want something checked below this #
# INTERNAL # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#          #                       then sorry; you have been blacklisted #

#
# Path to file currently being run
#
__distribution_static__item=""

#
# Current test name
#
__distribution_static__test_name=""

__distribution_static__ck_conv_pam_d() {
    #
    # Check PAM module configs
    #
    local path=$1           # path to check file at
    local fail=false        # did check fail?
    local module            # each .so module seen in $path
    for module in $(grep -Eo 'pam_[[:alnum:]]+\.so' "$path" | sort | uniq);
    do
        rlRun "! yum provides '*/$module' | grep 'No Matches found'" \
            0 "$CkName:$path:$module" \
         || fail=true
    done
    $fail && distribution_dump__file -E -s "$path"
}

__distribution_static__ck_conv_python_shebang() {
    #
    # Check Python binaries' shebang lines
    #
    # Based on this proposal:
    #
    #     https://fedoraproject.org/wiki/Features/SystemPythonExecutablesUseSystemPython
    #
    # The document is not complete on details but at some places the policy
    # is being implemented.  This test verifies that if shebang is present,
    # it starts with `#!/usr/bin/python`.
    #
    local path=$1       # path to check file at
    head -1 "$path" > tmp/line1
    grep -q '^#!' tmp/line1 || {
        rlLogDebug "no shebang, skipping: $path"
        rm tmp/line1
        return 0
    }
    rlRun "grep -qwEe '^#! */usr/bin/python[23]?' -e '^#! */usr/libexec/platform-python' tmp/line1" 0 "$CkName:$path" || {
        head "$path" | distribution_dump__pipe FILE_HEAD
    }
    rm tmp/line1
}

__distribution_static__rel_conv_python_shebang() {
    #
    # Decide if this test is relevant based on distribution
    #
    rlIsRHEL '>=7'
}

__distribution_static__ck_syntax_bash() {
    #
    # Check files for Bash syntax
    #
    local path=$1
    rlRun "bash -n '$path' 2>err" 0 "$CkName:$path"
    distribution_dump__file -E -s err
}

__distribution_static__ck_syntax_python_guessbin() {
    #
    # Guess which python binary is applicable
    #
    # First, consult distribution_static__bltnopts, then guess from path,
    # next apply heuristics on rpmdata/requires.   Finally scream a warning
    # and use hardcoded /usr/bin/python.
    #
    local reqs
    local it_was_2='echo /usr/bin/python2; return 0'
    local it_was_3='echo /usr/bin/python3; return 0'
    local it_was_P='echo /usr/libexec/platform-python; return 0'
    __distribution_static__opt pybin && return 0
    case $path in
        /usr/lib/python2*) eval "$it_was_2" ;;
        /usr/lib/python3*) eval "$it_was_3" ;;
    esac
    reqs=$(
        grep python rpmdata/requires \
          | sed 's/[[:space:]][[:space:]]*/ /g; s/^[[:space:]]*//; s/[[:space:]]*$//'
    )
    if grep -qF 'python(abi) = 2.' <<<"$reqs"; then
        eval "$it_was_2"
    elif grep -qF 'python(abi) = 3.' <<<"$reqs"; then
        eval "$it_was_3"
    elif grep -q '/usr/bin/python2\>' <<<"$reqs"; then
        eval "$it_was_2"
    elif grep -q '/usr/bin/python3\>' <<<"$reqs"; then
        eval "$it_was_3"
    elif grep -q '/usr/libexec/platform-python\>' <<<"$reqs"; then
        eval "$it_was_P"
    else
        rlLogWarning "$(distribution_static__cmt): could not guess python binary path, falling back to /usr/bin/python"
        rlLogWarning "hint: to avoid this warning, add 'syntax.python:pybin=/correct/binary' to distribution_static__bltnopts."
        echo "/usr/bin/python"
        return 2
    fi
}

__distribution_static__ck_syntax_python() {
    #
    # Check files for Python syntax
    #
    local path=$1       # path to check file at
    local pybin         # path to python binary
    pybin=$(__distribution_static__ck_syntax_python_guessbin)
    echo "compile(open('$path', 'rU').read(), '', 'exec')" \
      | rlRun "$pybin - 2>err" \
            0 "$CkName:$path"
    distribution_dump__file -E -s err
}

__distribution_static__rel_rpmdata_fedorahosted() {
    #
    # True if freeform.rpmdata.fedorahosted is relevant here
    #
    rlIsRHEL   '>=7.5' && return 0
    rlIsFedora '>=25'  && return 0
    return 1
}

__distribution_static__ck_rpmdata_fedorahosted() {
    #
    # fedorahosted.org has beeen retired
    #
    # https://fedoraproject.org/wiki/Infrastructure/Fedorahosted-retirement
    #
    rlRun "grep -qFw fedorahosted.org rpmdata/info" \
        1 "$(distribution_static__cmt): fedorahosted.org not mentioned in rpm info"
    rlGetPhaseState || distribution_dump__file -E rpmdata/info
}

__distribution_static__error() {
    #
    # Show internal error $1 properly
    #
    # One should not use `rlFail "error message"`, since rlFail is an
    # assert and asserts should always bear "positive" comment (eg.
    # `rlRun "true" 0 "all is OK"`).
    #
    # Instead we should log error via rlLogError.  Since beaker and
    # other tools do not properly bring that into user's attention,
    # we can "abuse" rlFail to trigger failure, but this time just add
    # a specific unique message that cannot be confused with SUT-related
    # assert.
    #
    local msg   # each message
    for msg in "$@";
    do
        rlLogError "$msg"
    done
    rlFail "(INTERNAL TEST ERROR)"
}

__distribution_static__make_links() {
    #
    # Create set of symlinks for faster grepping (grep -R)
    #
    local path          # each path
    local safename      # "safe" version of path
    mkdir files.links
    while read -r path;
    do
        safename="${path////_}"         # '/' => '_'
        safename="${safename// /_}"     # ' ' => '_'
        ln -s "$path" "files.links/$safename" || return 1
    done <all/files
}

__distribution_static__make_rpmdata() {
    #
    # Make RPM info in rpm directory
    #
    local arg
    mkdir -p rpmdata
    for arg in $(__distribution_static__rpmargs);
    do
        rpm -q --"$arg" "$Package" >"rpmdata/$arg"
    done
}

__distribution_static__make_rpmreal() {
    #
    # Store real state of info tracked in rpm database
    #
    # Generate output in same format as rpm --dump, but reflecting
    # real state of files.
    #
    local path          # path as in rpm --dump (but reality)
    local size          # ^^
    local mtime         # ^^
    local digest        # ^^
    local mode          # ^^
    local owner         # ^^
    local group         # ^^
    local isconfig='~'  # ^^
    local isdoc='~'     # ^^
    local rdev='~'      # ^^
    local symlink       # ^^
    local stats         # some of above collected by stat
    local hmode         # full mode in hex format (to make $mode)
    cut -d' ' -f1 rpmdata/dump \
      | while read -r path; do
            symlink=X
            digest=0000000000000000000000000000000000000000000000000000000000000000
            test -e "$path" || continue
            stats=$(stat -c "size=%s; mtime=%Y; hmode=%f; owner=%U; group=%G" "$path")
            eval "$stats"   # safe because none of above ^^ can include funny chars
            test -d "$path" && size='~'
            if test -L "$path"; then
                symlink=$(readlink "$path")
            elif test -f "$path"; then 
                digest=$(sha256sum "$path")
                digest=${digest%% *}
            fi
            mode=$(printf '0%o\n' "0x$hmode" | sed 's/^00*/0/')     # ..is how --dump formats it
            echo "$path $size $mtime $digest $mode $owner $group $isconfig $isdoc $rdev $symlink"
        done >rpmdata/dump.real
}

__distribution_static__rpmargs() {
    #
    # List valid /usr/bin/rpm args
    #
    {
        echo info
        echo changelog
        echo list
        echo dump
        echo configfiles
        echo docfiles
    #   echo conflicts
    #   echo enhances
    #   echo obsoletes
        echo provides
    #   echo recommends
        echo requires
    #   echo suggests
    #   echo supplements
        echo scripts
        echo triggers
        echo triggerscripts
    }
    #FIXME: enable also more recent args
}

__distribution_static__make_lists() {
    #
    # Make lists of "our" files/dirs
    #
    local path          # each path
    mkdir -p all
    touch all/symlinks all/directories all/files
    rpm -ql "$Package" \
      | sort \
      | while read -r path;
        do
            test -L "$path" && echo "$path" >> all/symlinks && continue
            test -d "$path" && echo "$path" >> all/directories
            test -f "$path" && echo "$path" >> all/files
        done
    true
}

__distribution_static__make_lists_ext() {
    #
    # Make lists based on file extension
    #
    local fpath     # path from 'files' list
    local fname     #  ^^  basename
    local fnext     #       ^^  extension
    local fncore    #       ^^  name "core" (extension dropped)
    mkdir -p ext
    while read -r fpath;                # /path/to/file.xml || /to/README
    do
        fname="${fpath##*/}"            # 'file.xml' || 'README'
        fncore="${fname%.*}"            # 'file'     || 'README'
        fnext="${fname#$fncore}"        # '.xml'     || ''
        test -n "$fnext" || {
            echo "$fpath" >> "ext/NO.EXT"
            continue
        }
        fnext="${fnext#.}"              # 'xml'      || ''
        echo "$fpath" >> "ext/$fnext"
    done <all/files
}

__distribution_static__make_lists_mime() {
    #
    # Make lists based on MIME type
    #
    local line          # each line from file(1) utility
    local fpath         #       ^^ only file path
    local mtype         #       ^^ only MIME type
    local mtype_a       #                ^^ only "left" part
    local mtype_b       #                ^^ only "right" part
    mkdir -p mime
    file --mime-type -f all/files \
      | while read -r line;                    # /path/to/file:    text/html
        do
            mtype="${line#*:}"              # '    text/html'
            mtype="${mtype// /}"            # 'text/html'
            fpath="${line%:*}"              # '/path/to/file'
            mtype_a="${mtype%/*}"           # 'text'
            mtype_b="${mtype#*/}"           # 'html'
            test -n "$mtype_a" -a -n "$mtype_b" || {
                rlLogWarning "weird MIME type; ignoring: $mtype"
                continue
            }
            mkdir -p "mime/$mtype_a"
            echo "$fpath" >> "mime/$mtype_a/$mtype_b"
        done
}

__distribution_static__make_lists_dist() {
    #
    # Make lists based on distribution conventions
    #
    mkdir -p dist
    grep ^/etc/pam.d ext/NO.EXT \
      > dist/pam.d
    true
}

__distribution_static__make_lists_heur() {
    #
    # Make lists based on heuristics
    #
    mkdir -p heur

    cat mime/text/x-shellscript \
        ext/sh \
        ext/bash \
        2>/dev/null \
      | sort \
      | uniq \
      > heur/bash

    cat mime/text/x-python \
        ext/py \
        2>/dev/null \
      | sort \
      | uniq \
      > heur/python
}


__distribution_static__ls_builtins() {
    #
    # List all builtin tests to consider
    #
    # If any arguments are seen, list them; otherwise list all known
    # (hardcoded) builtins.
    #
    test -n "$1" && {
        printf '%s\n' "$@"
    }
    echo conv.python.shebang
    echo syntax.bash
    echo syntax.python
    echo conv.pam_d
    echo freeform.rpmdata.fedorahosted
}

__distribution_static__opt() {
    #
    # Value of option $1 of current builtin check from $distribution_static__bltnopts
    #
    # Return 1 if value was not specified, 0 otherwise.  (Value can be
    # specified as empty.)
    #
    local wkey=$1
    local match
    match=$(
        #shellcheck disable=SC2001
        sed 's/,/\n/' <<<"$distribution_static__bltnopts" \
          | grep -e "^$CkName:$wkey="
    )
    test -n "$match" || return 1
    echo "${match#*=}"
}

__distribution_static__run_builtins() {
    #
    # Run built-in check $1
    #
    local CkName        # each check name
    local fn            # each check function
    local list          # each check input list
    local relevant      # each check relevancy function name
    for CkName in $(__distribution_static__ls_builtins "$@");
    do
        relevant=true
        case $CkName in
            conv.pam_d)
                list=dist/pam.d
                fn=__distribution_static__ck_conv_pam_d
                ;;
            conv.python.shebang)
                list=heur/python
                fn=__distribution_static__ck_conv_python_shebang
                relevant=__distribution_static__rel_conv_python_shebang
                ;;
            syntax.bash)
                list=heur/bash
                fn=__distribution_static__ck_syntax_bash
                ;;
            syntax.python)
                list=heur/python
                fn=__distribution_static__ck_syntax_python
                ;;
            freeform.rpmdata.fedorahosted)
                relevant=__distribution_static__rel_rpmdata_fedorahosted
                fn=__distribution_static__ck_rpmdata_fedorahosted
                ;;
            *)
                __distribution_static__error \
                    "unknown check: $CkName"
                return 3
                ;;
        esac
        case $CkName in
            freeform.*)
                rlPhaseStartTest "$PackageNvr: built-in free-form check: $CkName"
                    if ! $relevant; then
                        rlLogInfo "skipping test not applicable for this distribution"
                    else
                        __distribution_static__run_ffck $fn "$CkName"
                    fi
                rlPhaseEnd
                ;;
            *)
                rlPhaseStartTest "$PackageNvr: built-in file-based check: $CkName"
                    if ! $relevant; then
                        rlLogInfo "skipping test not applicable for this distribution"
                    elif test "$(wc -l <$list)" -eq 0; then
                        rlLogInfo "no applicable items"
                    else
                        <$list __distribution_static__run_ck $fn "$CkName"
                    fi
                rlPhaseEnd
                ;;
        esac
    done
}

__distribution_static__run_customs() {
    #
    # Run custom check $1
    #
    local ckdef     # each check definition expression
    local list      # list specification (relpath in list cache)
    local ckfn      # custom check function
    local lsfn      # custom listing function
    for ckdef in "$@";
    do
        case $ckdef in

            /:|:*|*:|/:*|*:/)
                __distribution_static__error \
                    "invalid custom check definition: '$ckdef'"
                ;;

            # simple check with list
            #
            */*:*)
                list=${ckdef%:*}
                ckfn=${ckdef#*:}
                rlPhaseStartTest "$PackageNvr: custom simple check: $ckdef"
                    type -t "$ckfn" >/dev/null || {
                        __distribution_static__error \
                            "no such check function: '$ckfn'"
                        continue
                    }
                    test -f "$list" || {
                        __distribution_static__error \
                            "no such list: '$list'"
                        return 3
                    }
                    case $(wc -l <"$list") in
                        0)  rlLogInfo "no applicable items" ;;
                        *)  <"$list" __distribution_static__run_ck "$ckfn" "$ckfn" ;;
                    esac
                rlPhaseEnd
                ;;

            # simple check with function
            #
            *:*)
                ckfn=${ckdef#*:}
                lsfn=${ckdef%:*}
                rlPhaseStartTest "$PackageNvr: custom simple check: $ckdef"
                    type -t "$ckfn" >/dev/null || {
                        __distribution_static__error \
                            "no such check function: '$ckfn'"
                        continue
                    }
                    type -t "$lsfn" >/dev/null || {
                        __distribution_static__error \
                            "no such listing function: '$lsfn'"
                        continue
                    }
                    ( "$lsfn" ) \
                      | __distribution_static__run_ck "$ckfn" "$ckfn"
                rlPhaseEnd
                ;;

            # free-form check
            #
            *)
                rlPhaseStartTest "$PackageNvr: custom free-form check: $ckdef"
                    type -t "$ckdef" >/dev/null || {
                        __distribution_static__error \
                            "check function not defined: '$ckfn'"
                        continue
                    }
                    ( "$ckdef" )
                rlPhaseEnd
                ;;

        esac
    done
}

__distribution_static__run_ffck() {
    #
    # Run free-form test fn $1 under name prefix $2
    #
    local test_fn=$1        # test function name
    local test_name=$2      # test name
    case $distribution_static__blacklist in
        filter)
            grep -qxFe "$test_name:" BLACKLIST && {
                rlLogInfo "skipping blacklisted test"
                return 0
            }
            ( __distribution_static__item="" \
              __distribution_static__test_name="$test_name" \
              "$test_fn" )
        ;;
        ignore)
            ( __distribution_static__item="" \
              __distribution_static__test_name="$test_name" \
              "$test_fn" )
        ;;
        verify)
            if grep -qxFe "$test_name:" BLACKLIST;
            then
                ( __distribution_static__item="" \
                  __distribution_static__test_name="$test_name" \
                    "$test_fn" )
                rlGetPhaseState \
                 && __distribution_static__report_stale "$test_name:"
            else
                ( __distribution_static__item="" \
                  __distribution_static__test_name="$test_name" \
                  "$test_fn" )
            fi
        ;;
    esac
}

__distribution_static__squash_lists() {
    #
    # Remove duplicates from basic lists
    #
    # Note that due to how multilib works, file lists may contain
    # duplicate items (`rpm -ql a-multilib-package`).
    #
    < all/symlinks    sort | uniq > all/symlinks.uniq
    < all/directories sort | uniq > all/directories.uniq
    < all/files       sort | uniq > all/files.uniq
    mv all/symlinks{.uniq,}
    mv all/directories{.uniq,}
    mv all/files{.uniq,}
}

__distribution_static__usage() {
    #
    # Bad usage
    #
    __distribution_static__error \
        "usage: distribution_static__checks [-R] [-B] [-b BUILTIN]... [-c CUSTOM_CHECK]... [PKG]"
}

__distribution_static__report_stale() {
    #
    # Report possibly stale keys $@
    #
    test -n "$1" || return 0
    __distribution_static__error \
        "following items on blacklist did not trigger fail:" \
        "$@"
}

__distribution_static__run_ck() {
    #
    # Run test fn $1 under name prefix $2 with all paths from stdin
    #
    local test_fn=$1        # test function name
    local test_name=$2      # test name
    local item              # each path to run check function against
    local errs_pre          # number of errors before a check
    local errs_post         #              ^.. after a check
    local blist_mode        # blacklist mode
    local blist_key         # each processed blacklist item
    local blist_stale=()    # stale blacklist items (collected in verify mode)
    blist_mode=$distribution_static__blacklist
    while read -r item;
    do
        blist_key=$test_name:$item
        case $blist_mode in
            filter)
                grep -q "^$blist_key\\b" BLACKLIST && continue
                ( __distribution_static__item="$item" \
                  __distribution_static__test_name="$test_name" \
                  "$test_fn" "$item" )
            ;;
            ignore)
                ( __distribution_static__item="$item" \
                  __distribution_static__test_name="$test_name" \
                  "$test_fn" "$item" )
            ;;
            verify)
                if grep -q "^$blist_key\\b" BLACKLIST;
                then
                    rlGetPhaseState; errs_pre=$?
                    #FIXME: remove this bailout after bz1370266
                    test $errs_pre -eq 255 && {
                        # don't waste more resources in this phase
                        blist_mode=ignore   # ignore: user still wants to know what those items do
                        __distribution_static__error \
                            "too many FAILs; 'verify' mode disabled until next phase" \
                            "lobby for BZ#1370266 if this bothers you"
                    }
                    ( __distribution_static__item="$item" \
                      __distribution_static__test_name="$test_name" \
                        "$test_fn" "$item" )
                    rlGetPhaseState; errs_post=$?
                    test $errs_post -eq $errs_pre \
                     && test "$blist_mode" = "verify" \
                     && blist_stale=("$blist_key")
                else
                    ( __distribution_static__item="$item" \
                      __distribution_static__test_name="$test_name" \
                      "$test_fn" "$item" )
                fi
            ;;
        esac
    done
    __distribution_static__report_stale "${blist_stale[@]}"
}

distribution_static__LibraryLoaded() {
    #
    # Do nothing (handler needed by beakerlib)
    #
    :
}

#----- SFDOC EMBEDDED POD BEGIN -----#
#
# This part is automatically generated by extracting POD page from rest of
# the code by sfdoc and embedding it using an experimental utility.
#
# In other words, do not edit any code between this comment and line
# containing SFDOC EMBEDDED POD END or YOUR CHANGES WILL BE LOST.
#

#shellcheck disable=SC2217
true <<'=cut'
=pod

=encoding utf8

=head1 NAME

distribution/static - Static file checking

=head1 DESCRIPTION

Static file checking

This library provides single function to help perform static file
checking of installed RPM package.  By default,  several built-in
checks are run.  If that is enough, all you need is call the
function and it will take care of everything else.

However, aside from this simple scenario, main strength of this
function is that it already sorts files into lists in such a way
that adding custom checks becomes easy.

Another strength of this library is its simple but dynamic blacklisting
so that your tests can be flexible but remain easy to understand and
maintain.


=head1 BUILT-IN CHECKS

Built-in checks are few, to start with:

 *  `syntax.python` -- syntax check for all possible Python scripts,

 *  `syntax.bash` -- syntax check for all possible Bash scripts.

 *  `conv.pam_d` -- check that files in /etc/pam.d/ are valid.

 *  `conv.python.shebang` -- check for all possible Python scripts
    that they use `#!/usr/bin/python`, not `#!/usr/bin/env`


=head1 CUSTOM CHECKS

Before understanding custom checks, we first need to look at
way how file lists are organized.  Each check runs inside a directory
organized like this:

    .
    ├── BLACKLIST
    ├── all
    │   ├── directories
    │   ├── files
    │   └── symlinks
    ├── relics
    ├── dist
    │   └── pam.d
    ├── ext
    │   ├── NO.EXT
    │   ├── bash
    │   └── conf
    ├── files.links
    │   ├── _etc_foo_foo.conf -> /etc/foo/foo.conf
    │   ├── _usr_share_lib64_foo_bar.so -> /usr/share/lib64/foo/bar.so
    │   ├── _usr_share_lib64_foo_baz.so -> /usr/share/lib64/foo/baz.so
    │   └── ...
    ├── heur
    │   ├── bash
    │   └── python
    ├── mime
    │   ├── application
    │   │   └── xml
    │   └── text
    │       ├── plain
    │       └── x-shellscript
    ├── rpmdata
    │   ├── dump
    │   ├── info
    │   ├── list
    │   ├── provides
    │   ├── requires
    │   └── scripts
    └── tmp

where "leaves" are individual path lists:

 *  `all/..` - just based on basic UNIX type,
 *  `BLACKLIST` - is generated by `distribution_static__mkblacklist()`,
 *  `ext/..` - lists per file extension,
 *  `mime/..`  - lists per MIME type as detected by file(1) utility,
 *  `heur/..` - lists based on heuristics wired in this module,
 *  `dist/..` - lists based on conventions given by distribution.

`files.links` is not a list but a "flat" directory with symlinks to
all files in the package.  This is useful if you want to use a tool
with recursive mode such as grep, eg. `grep BAD_STRING -R files.links`
may have vastly better performance than calling grep for each file
in the package.

`tmp` is also not a list, it's a directory designated for custom checks
to allow keeping ad-hoc data (see Guildelines section of this manual).
`relics` is similar except that this directory will be kept and
submitted using rlFileSubmit along with all lists.

`rpmdata` is another 'special' case; files here are direct exports from
RPM database; where each file represents output of rpm query, where
the query option corresponds to file name under rpmdata.  For example,
output of `rpm --info` is saved under `rpmdata/info`.  As an addition,
rpmdata/dump.real contains report similar to rpmdata/dump, but reflecting
real state of filesystem rather than RPM database.  See RPMDATA MIRROR
REPORT section for more details.

Now, custom checks are added by implementing a check function and
specifying it (and one of above lists, if needed) when calling
`distribution_static__checks()`.

There are two types of custom checks:


=head2 Simple, typed check

This is a simple function that runs on a particular path list as
described above.  For each path, the check function is called with
single argument of the path.

The list can be relative path within the above structure, but also
*another function*.  This helps make very specific checks by
combining lists generated by this library and custom, package-specific
filtering.

The format can be one of:

    SOME/LIST:SIMPLEFN
    LISTFN:SIMPLEFN

where LIST can be filename path relative to the directory described
above.  Alternatively, you can write own function to produce the
list (LISTFN); in that case you will use the second form.  SIMPLEFN
is function  provided by you; it should accept path name of file being
checked as single argument, and contain at least one beakerlib assert.

For example, check 'all/files:foo' would call function `foo()` on each
file (each line in `all/files` file).  Check 'heur/python:bar' would call
`bar()` on each path from `heur/python` list.  Last, a check 'heya:baz'
would run `baz()` with every line generated by calling `heya()`.


=head2 Free form check

Free-form check is just a user-defined function called in the
path list directory described above.

Two great advantages of *simple check* is that you don't have to care
about the iteration code and it's easy to combine with any cached
or custom-created lists.  Free-form check trades these feats for
flexibility while still retaining access to cached lists.

=head2 Guildelines

When writing custom checks, try to follow these guidelines:

 *  Do not change directory (if you absolutely have to, use pushd/popd).

 *  Do not write anywhere except tmp/ sub-directory, created for you for
    this purpose.

 *  Prefix each assert with relevant filename (for simple checks, this
    is passed as $1, for free-form, use absolute paths as read from
    cached lists).


=head1 BLACKLISTING

If a function named `distribution_static__mkblacklist()` is defined,
it must print a blacklist in form of lines as:

    TEST_NAME:PATH

Where TEST_NAME is name of the built-in test or a custom check function
(SIMPLEFN), from which the PATH should be excluded.


=head1 RPMDATA MIRROR REPORT

File rpmdata/dump.real is created by this module and contains data in
similar format as rpm --dump (ie. rpmdata/dump file), but reflecting
real stat  This file can be useful when debugging rpm verification
failures.

The report will never be exactly the same, though, for several reasons.
First, some fields cannot be reproduced by this module (eg. isconfig) or
not reliably so (eg. rdev, size for directories...).  Second, files that
were deleted from filesystem will be simply skipped.

Also note that rpm allows explicitly excluding some fields from the rpm
verification using %noverify field.  That is, these fields could be
different in rpmdata/dump.real, and rpm check could still pass.


=head1 EXAMPLE

Skipping some boilerplate, this is body of a simple example of
this function in action:


    usepy3() {
        rlRun "head -1 $1 | grep '#/usr/bin/python3'" \
            1 "$(distribution_static__cmt) Python 3 is used"
               #\
        ## the comment is not mandatory, but we have added one
        ## and by use of distribution_static__cmt() we ensure
        ## the comment contains file path and check name already
        ## formatted to copy/paste into blacklist
    }

    modules() {
        grep -w /usr/lib/foo/modules heur/python
                                    #\
        ## we'll re-use existing list heur/python and just
        ## filter it according to our specific criterion
    }

    distribution_static__mkblacklist() {
        echo usepy3:/usr/share/doc/foo/bad_examples/obsolete.py
                    #\
        ## iow, this particular file will be skipped by
        ## usepy3() test.  Few hints here:
        ##  *  Instead of 'usepy3', we could also have used
        ##     a custom built-in check name
        ##  *  In case path  changes per distribution, we can
        ##     pull it from rpm database
    }

    rlJournalStart

        rlPhaseStartSetup 'init'
            rlImport "distribution/static"
        rlPhaseEnd

        distribution_static__checks -c modules:usepy3 foo

    rlJournalPrintText
    rlJournalEnd

Explanation:  The test is written for package 'foo'.  That is,
`rpm -ql foo` will be used as basis for all file lists.  Built-in checks
are called by default; we're topping this up with out custom "simple
check".

We could have used one of provided lists, eg. `heur/python:usepy3`
("things that look like Python") but we decided to focus only on
particular subset of that.


=head1 VARIABLES

=over 8


=item I<$distribution_static__blacklist>

Blacklisting mode: 'filter', 'ignore' or 'verify' (default: 'filter')

'filter' is the usual mode when blacklist is working.  'ignore' will
stop filtering, just as if blacklist was empty.

'verify' mode will try to detect obsolete blacklist items: it will
run checks for all item, but will raise warning for items that would
be filtered but did not really fail.

It's recommended to run your tests with 'verify' once in a while, after
a rebase or major change.


=item I<$distribution_static__bltnopts>

Options for builtins

Comma-separated list of K=V pairs where each KEY must
start with builtin name, colon and option name.

    BLTNNAME:OPTNAME=foo,BLTNNAME:OPTNAME=bar

These values are available to the builtin via __distribution_static__opt()
function.

=back


=head1 FUNCTIONS

=over 8


=item I<distribution_static__cmt()>

Get comment for rlRun inside custom check

Assert comments are not mandatory but using this function you
this function will help you create comment:

    CURRENT_CHECK:CURRENT_PATH

which can be directly used in blacklist.


=item I<distribution_static__checks()>

For a package, run built-in checks plus custom checks

Usage:

     distribution_static__checks [-R] [-B] [-b BUILTIN].. [-c CUSTOM_CHECK].. PKG"

For package PKG, make lists and run

 *   basic RPM integrity check, unless suppressed by -R,

 *   all built-in checks, unless suppresed by `-B` or specified by `-b`,

 *   all custom checks, if specified by -c.

Finally, it will collect all intermediate relics (file lists, RPM data
and files dropped by custom checks, if any) as `PKG-NVR-relics.tar.gz`
ans upload it using rlFileSubmit for later reference.

All necessary phases are created.

Each CUSTOM_CHECK has to have one of this form:

    SOME/LIST:SIMPLEFN
    LISTFN:SIMPLEFN
    FREEFN

where SOME/LIST is a relative path to one of lists as described in
CUSTOM CHECKS section, LISTFN is name of a user-defined listing
function), SIMPLEFN is your simple check function name, and FREEFN
is name of your free-form check function.  Read CUSTOM CHECKS
section of this manual for details.


=item I<distribution_static__LibraryLoaded()>

Do nothing (handler needed by beakerlib)

=back

=cut
#----- SFDOC EMBEDDED POD END -----#
